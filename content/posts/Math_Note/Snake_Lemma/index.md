---
categories:
- Mathematics
tags:
- Algebra
- Category Theory
title: "蛇年，Snake Lemma！"
description: 蛇年我也试证一下蛇引理
image: Post Shelter-Inaba Kumori.png
date: 2025-02-27
math: true
draft: false
---

*看了好多证明蛇引理的视频，我也来试试~ 蛇年到了，重在参与嘛*

*头图出自 [ぬくぬくにぎりめし](https://twitter.com/NKNK_NGRMS) 太太， 为 [稲葉曇](https://space.bilibili.com/26040194) 所作的 [ポストシェルター](https://www.bilibili.com/video/BV1jS4y1y7Yf/) (Post Shelter)的曲绘。支持正版，就只有30秒试听了（）*

{{< music auto="https://music.163.com/#/song?id=1921984877" loop="none">}}

## 写在最前

本命年到啦~！作为一个代数爱好者（自称，其实是名词党），最近在B站看到了很多的关于怎么证明蛇引理（Snake Lemma）的视频，比如[这个视频](https://www.bilibili.com/video/BV1FZFNezE6D)。以前在自学代数的时候也遇到过这么个引理，但是看到这个部分的时候已经人快晕了（大概就是看完这个之后就抛弃了那本书吧，*Algebra: Chapter 0*），所以几乎等于没学过。这次看到这么多关于蛇引理的视频，自然是学习一下，这里也做一个记录吧。在本文中你将看到：

- 你在说些什么？
- 这么简单的前置竟然也要？
- 你这里跳步了吧？
- 就算我证的不好，我证的很搞笑也不行吗？

之类的高血压时刻。为了您的身心健康，如果你打算认真了解蛇引理的话，我还是不建议你深究这篇文章。当然，如果你是找乐子的话，我希望这篇文章能带给大家笑容。这篇文章的面向读者应该对最基础的代数有了解，比如集合啊，函数啊之类的，如果会线性代数就更好了，别的东西会中途提到，毕竟是名词党写的文章，当然起点会很低的吧（笑）。话不多说，开始吧。

## 简单介绍

蛇引理究竟是什么呢？这是一个代数学定理，简单来讲，它做的事情和很多代数学定理一样：从已有的两个东西来创造出新的东西。比如，如果我们有一个集合以及集合上的等价类/等价关系，我们就可以构建出来一个商集；给定一个群以及它的正规子群，我们就可以构建出商群；把两个空间 $\mathrm{R}$ 叉乘起来（笛卡尔积），我们就得到了 $\mathrm{R}^2$。

那么蛇引理是针对什么样的代数对象呢？这里就要尝试引入我们的第一个概念：正合列 (Exact Sequence)

### 正合列，但是先别急

正合列，同调代数中的重要对象，是由链复型添以特殊的条件而产生的。链复型又是什么？链复型是一系列的交换群或者模通过同态连接起来，且相邻两个同态的复合为0。

也许你要说：天哪你在说什么鬼东西，这都是啥啥啥呀。既然我们假定读者只拥有最基础的代数知识，我们就从最基础的开始介绍吧。名词党最喜欢的名词介绍环节，启动！

#### 群，交换群

上面说链复型是由交换群或者模带上同态构成的，为了简单，我们就不介绍模 (Module) 了，专注于交换群。
<details><summary>但是模是什么？我要看口牙！</summary>如果有人讲模之类的话，可以认为就是一个差一点的线性空间，它就差在标量不再是数域中的元素了，而是环 (Ring) ，一种乘法可能没有逆元的神奇代数结构，里面的元素。这里指出，环想要变成域（有的地方管域叫体，英文都是 Field）的话只需要让环满足交换律，并且它的每个非 0 元素都有乘法逆元就好了。</details>

那么交换群，或者从头来讲，群，又是什么呢？有人会讲：群就是对称！有对称，就有群！挺好的，但是对称这种几何元素偏偏要符号化成群元素，这一步我倒是走了蛮久的。我们速通嘛，就说简单一点，尽可能地不丧失严谨性吧。群 (Group)，最为代数学中几乎是最基础的代数结构，和其余的许许多多数不清的代数结构类似，遵循这样的特点：

1.  从集合而来。它的 “底下” 一定是一个集合。这样我们就可以讨论这个代数对象中的元素了。
2.  它的内部有一个或者多个 “运算”。我们可以想象我们早已熟悉的乘法。既然是运算，我们对这么个东西有这样的要求：
    1.  首先运算是两个元素同时参与的。相乘的总是（起码）两个数。注意不一定非得是不一样的数哦。
    2.  两个元素经过运算之后应该得到一个元素。两个数相乘之后给出的也是一个数字。
    3.  这点不太明显，但是我们的运算总是应该从这个集合来，到这个集合里去。比如 $1\times 1\neq\mathrm{苹果}$。

这样就可以有一个（很基础的一些）代数结构啦。而我们的群，也正是这样的一个代数结构。不过它还有这样的特点：

1. 群的运算必须要是可以结合的。这意味着如果 $abc \neq (ab)c \neq a(bc)$，那它就不是群。（天啊真的有这样的神经结构吗）
2. 群的运算**不需要**是交换的。其实不交换的东西很常见，例如我们要先穿袜子再穿鞋，这肯定和光脚穿鞋后再套个袜子是不一样的啦。学过线性代数的朋友应该更有体会：矩阵乘法是不交换的。
3. 群得有单位元。何谓单位元？这不是元素吗？这里的单位元是和运算强相关的，说的就是群里的任何元素和这个单位元做运算之后一定得到的是它们自己。
4. 群中元素都得有逆元。没错，这里逆元的概念也是和运算相关的。所谓 “逆”，就是要把一个元素 “逆转” 回单位元。可以想象单位元就是某个出发的位置，每个元素都代表着某个让你移动的方式。而某个元素对应的逆元，就像你移动之后让你移动回原点的移动方式。能走出去，也得能走回来。就是这样。

其实上面的这些内容，经过一些整理的话就可以变成比较严格的群的定义了。然而严格定义谁都能查，这里也就偷个懒啦~ 这里指的指出的是，群上的运算我们一般就叫它乘法。而且在代数的语境下，很多运算我们都叫它乘法！所以在讨论代数结构中的乘法时要注意上下文哦~

<details><summary>所以群的对称意义究竟在哪？</summary> 我们讲，集合中的元素位置其实是无所谓的，比如集合 $\{1,2\}$ 和集合 $\{2,1\}$ 是一模一样的。那么，群的对称的意义，就在于群中的元素有两重含义：集合内的一个小不点，以及代表了如何操作这个集合的一个符号。

我们提到过，群的运算是需要满足上面一大堆条件的。这些条件指向了这样的一个神奇的结果：两个群中的元素相乘，我们可以有意识地将其中一个元素作为操作方式，将另一个元素看作群中茫茫多（或者很少，也许）元素中的某个元素。而这样的运算结果又是群中的某一个元素。

然后我们再想象这样一副图景：桌子上有一副扑克牌，每一张都分开放，放的很整齐。现在你尝试把这些扑克牌重新排列，这个排列方式取决于你开始重排前看到的第一张牌。在重新排列时，你肯定需要一张一张地取，取到之后会根据你看到的第一张牌来思考应该把它放在哪里，最后你就把它放在了对应的位置。在重复54遍 “取-看-放” 的过程之后，你会惊奇地发现：天哪，竟然又得到了一副扑克牌（？）

你可能觉得这个发现很无聊，但是这就是对称：在某种操作下又回到自身了。你也许会说：不！位置变了！但是还记得吗？集合中元素位置是无关紧要的。我们这里其实就是在讲群对自身的作用。那么群可以对别的集合进行作用吗？当然！只要某个作用方式满足群的条件，也就是说如果你先做了一个操作，又做了另一个操作（这样就操作两次了，对应群中的两个元素相乘）这俩操作实际上也是你可取操作的一种（群中元素运算后依旧在群里），以及别的条条框框，那么实际上你就是在对这个集合进行着群作用。

群中蕴含的对称，不在于群自己，而在于它能操作的对象。笨笨的我花了好久才明白这个道理 QAQ。
</details>

---

太棒了！群是什么，已经狠狠地理解了！那么交换群？诶！交换群一定是运算能满足交换律了吧！

是的，答案就是这么简单，且无聊。交换群 (Commutative Group)，就是能交换 (Commutativity) 的群 (Group)。你也许会对交换群感到失望，但是代数岂是如此无聊之物！？这一切的原因，其实是：我们还没有引入同态 (Homomorphism)。

#### 同态，同构，等价关系

首先，代数中［Homo-］的词头其实很常见（？）。这是代表着两个东西之间一定有什么相同的地方。而同态，正是指出了两个代数结构之间相同之处的东西。请注意这里用到的是 *代数结构* 而非 *群* 或者 *交换群*。同态广泛地存在于代数学中，到处都是同态。那么同态是什么呢？其实你早就见过了。对于 *集合* 这个最基础的代数结构而言，同态就是 *函数*，或者说 *映射*[^1]。既然函数是对于集合而言特殊的同态，那么对于群而言，特殊的同态是什么呢？很可惜，没有一个特别的名字，或者大家就直接叫群同态了。然而群同态确实是有其特殊之处的。我们稍后再细讲这种特殊点在哪，以及何来的“同”一字。

回忆我们很熟悉的集合上的函数，它有这样的特点：

1.  函数必须要有定义域，它是一个 *集合*，且这个集合里的每个元素都能被函数处理（作用）。不能说有个定义域的元素不能被函数吃掉，那就礼崩乐坏了。函数是不会剩饭的。
2.  函数必须要有陪域。他也是一个 *集合*。请注意这里不是说不是值域，而是陪域。值域是函数能吐出来的东西组成的集合，而陪域则是函数吐出来的东西一定会存在的集合。所以，很自然的，会有一些陪域上的元素不会有任何定义域上的元素去对应。
3.  定义域中的每个元素 *能且只能* 对应陪域上的一个元素，而陪域上的元素可以有0个，1个或者很多个定义域上的元素对应。这就像投篮，球可以投不中，可以一个球一个框，也可以很多球进一个大框里，但是不能一个球同时进两个框。
4.  判断两个函数是否相等（没错，函数作为数学对象是可以判断是否与另一个相等的）的铁则是：定义域相同，陪域相同，定义域上的每个元素通过两个函数作用后得到的结果总是一样的。也就是说，要检测函数的三个要素都是一样的。表达式也许会骗人，但 *函数的定义* 永远是诚实的。

天啊我怎么又讲了一遍函数是什么？原因是：函数，作为同态的一个例子，自然就包括了同态的许多特点。然而同态还有一个重要的特性，也是被冠以 “同” 字的原因：同态必须保持结构！我们没有在集合中看到这样的特点，是因为集合里什么结构都没有。也许有人说：集合里的元素都是有名字的呀？什么 1 啊 2 啊的，这不就有结构那样的东西了嘛。这里要明确的是：集合里这些看似特殊的元素，它们的特殊性全都源自于我们为了能区分它们所给的，甚至就是为了能数清楚这些元素，不至于把它们搞混。So，集合真的很单纯，它上面的结构都是后面赋予的。当然，你也可以说 “没有结构” 也是一种结构，因为 *函数不会把集合变成别的什么不是集合的东西*，保持了 “没有结构” 的特点（结构）。

哦，好，但是说了一圈，到底怎么保持结构？群同态到底是什么样的？观察上面函数的特点，我们提炼一下：

> 同态要有来有去，且来去都是同一类东西，不能来去之后东西不一样了。这说明 *同态不会给对象添加或删去任何结构*。

就是说，群同态只能连接两个群。或者，*一个群上如果作用了一个群同态，那么它就必须给出一个群*。这点对于其他所有的代数结构都是一样的。

还是一头雾水？是不是觉得随便哪个集合上的函数都能在集合变身成函数后也跟着变成同态？没关系，就群同态而言，我们其实可以写出群同态需要满足的特点（多亏了运算的存在）。

> 设有两个群 $G$ 和 $H$，它们之间有个从 $G$ 到 $H$ 的群同态 $\varphi$。我们记群 $G$ 的运算为 $\times_G$，记群 $H$ 的运算为 $\times_H$，群 $G$ 中有俩元素 $g_1$ 和 $g_2$。这样一来，由于 $\varphi$ 是群同态，有：
>
> $$\varphi(g_1 \times_G g_2) = \varphi(g_1) \times_H \varphi(g_2)$$

而且它有一个很神奇且重要的特点：群同态只能把一个群的单位元映射到另一个群的单位元。这点乍看很神奇甚至不可思议，但是经过简单的证明就可以得到这样的结论了。这也是为了保持群的结构而对群同态做出的一个很强的限制。这也说明了，代数结构越是复杂，同态的限制就会越大。

---

我们接下来介绍同构 (Isomorphism)。它在集合函数中的对应就是所谓的一一对应函数了。回忆所谓的单射和满射，单射说一个萝卜一个坑，满射说值域就是陪域。而同时满足这两个条件的话，这个函数就是一一对应的函数啦。我们立刻使用一些新词来讲这些事情，因为函数（映射）是集合间的同态嘛。

同态中有单态 (Monomorphism)，也有满态 (Epimorphism)。而同时满足这两点的，即为所谓的同构了。它们的要求和集合函数是一模一样的。然而还有别的定义方法，使用态射的逆（啊没错它们都是态射但是这就留到范畴论再说吧）即可定义同态的单或满。回忆之前学过的逆函数这一存在，一个函数的逆函数再作用到函数的话就会变成恒同映射（把一个元素映射到它自己）。这是一种双边逆，更常见的情况则是一个态射只有左逆或者只有右逆。*我们称有左逆的态射为单态，有右逆的态射为满态，有双边逆的则为同构*。这个我们不证，有兴趣可以挑一些例子看看。请把重点放在 “能不能找到原来的元素” 以及 “如果能找到原来的元素，那么一定会如何”，并注意函数的复合是从右到左的。

同构从字面意思来理解，是 “保持结构” 的映射。可是之前还说同态是保持结构的映射，这两个区别在哪里？事实上，同构比同态要求高多了。同构要求的是 “构造完全相同”，而同态则只要求 “是同一类东西，不会多结构，也不会丢结构”，却可以修改这个结构。比如，同态可以让一个大群变成一个小群，搞得里面的每个元素以前有更丰富的运算结果，结果到了小群里好多元素被捏在一起了，这些丰富的结果也就没了。而同构会很严格地将一个群变成另一个大小一模一样的群，它们结构的丰富程度或者精细程度是一模一样的。在只关心群这个整体以及它怎么与其他群发生转变，完全不关心群内部元素有什么特别之处时，我们可以说，*同构的两个群，它们在同构意义下可以被视作是相同的*。顺带一提，集合的同构就是映射到元素个数相同（集合的势相等）的另一个集合。这也是个大坑，感兴趣可以搜 Schröder–Bernstein 定理或者伯恩斯坦定理。

对于群而言，群的同态会把群的一个或几个元素捏在一起形成新群的一个元素。同态是创造新群的一个重要方式。但是假如我们考虑 *把几个元素捏在一起形成一个新的元素* 实际上意味着 *对原来的群中的元素进行分类*，那我们就会形成很有趣的结构，商群 (Quotient Group)。我们不会深入这部分，但是这个思想是极其重要的，因此我们需要介绍另一个概念：等价关系与等价类。

---

小学数学，甚至幼儿园数学，经常会遇到这样的题目：把一堆苹果分成若干份，每份有几个苹果；把苹果平均分成若干份，最后剩下几个苹果。这样的题目是为了让孩子熟悉除法，而我们这里则要指出，这就是除法，或者所谓的 “商” 所代表的含义。而我们在分苹果时所做的事情，就是在对苹果分类。

我们要如何进行分类呢？特别是对一堆苹果而言，分成堆时我们做了什么？也许我们有某个标准，也许就是简单的 “我乐意”，但分成堆的过程中每个苹果最终都有属于自己的一堆。假如我们要分成三堆，那么我们完全有理由将三堆起不同的名字，比如：科比，牢大，曼巴。这样一来，每个苹果就都有了一个属性，一个标签。而苹果之间有什么关系吗？有的。我们观察同一堆的苹果，如牢大这堆，会发现这样的（显而易见）的特点：

1.  一个属于牢大的苹果，那么他就属于牢大（？）
2.  如果一个苹果在牢大里，另一个苹果也在牢大里，那么它们俩就都在牢大里，不论进入牢大这堆的顺序
3.  如果苹果A和苹果B都在牢大里，苹果B和苹果C也在牢大里，那么苹果A和苹果C就一定在牢大这里。

不论分类手法如何，不管分类标准怎么样，上面这三条总是成立的。而在分好之后，对任何人都可以只宣称这堆苹果属于哪一堆，不用管它具体怎么样了。有人问这个苹果是哪个，都可以回答这个苹果是从科比或者牢大或者曼巴这堆里取出来的。

还是一头雾水？上面的例子是想说明这样的一件事：只要你选了，那就会形成一个标准，这个标准内的每个成员都会接受这样的束缚，而这个约束是有 *自反性*，*反身性* 和 *传递性*的。这些性质就刻画了一个 “关系”，称为 *等价关系*。我们刚刚用分好的类来说明这类关系一定存在，而反过来讲，根据这样的关系，也一定能进行这样的分类。最后分出来的 “每一堆”，我们就称为等价类。

分类是代数学中另一个极为重要的话题。有一些出色，重要且惊艳的研究正是建立在这样的分类问题上的，比如传说中的 *有限单群分类*，洋洋洒洒几千字的论文将整个单群分类问题整的明明白白。分类如此重要的原因还在于帮助我们创造新的代数结构，也就是所谓的 *商*。比如使用同态对群进行划分则会涉及著名的 *群同构基本定理*，描述了用同态下的等价关系创造出的商群有什么样的信息。

我们这里先不深入介绍商群，因为它将涉及到子群 (Subgroup)，陪集 (Coset)，正规子群 (Normal subgroup) 等概念，太啰唆了。这里只指出商群的记号为 $G/H$，其中 $G$ 和 $H$ 都是群，且 $H$ 是 $G$ 的正规子群。这个商群的元素是这样的：每个元素都是一个集合，这个集合内是群 $G$ 中的元素，并且这些群 $G$ 中的元素都相互等价，而这个等价关系则由群 $H$ 这样确定：元素 $a$ 和 $b$ 等价由 $a^{-1}b \in H$ 决定。换句话说，我们根据群 $H$ 制定了元素的分类标准，把分好类后的每个 “元素堆” 作为商群中的每个元素。能分多少堆，商群就有多少个元素。要注意的是由于等价关系，商群中每个元素（也就是 $G$ 中元素的集合）里都可以选出唯一的一个 $G$ 中元素来代表。

太棒啦！感觉智慧满大脑了~但是这么多前置了，和蛇引理有关系吗？还有多少前置需要呢？答案令人振奋呀：还有一节就好了！我们已经明白了同态是什么样的，交换群又是啥，商群里的元素怎么确定，有什么样的特点。我们只需要再看一看最后两个和同态有千丝万缕联系，作为 “群同构基本定理” 中的 C 位的两个特殊的代数对象，核 (Kernel) 与像 (Image)，就可以开始一窥蛇引理的神秘了~。

#### 核与像

核的概念其实很简单，它高度依赖于同态，本身是一个特殊的集合（我们先看它单纯的集合结构）。它是同态的定义域上所有能被对应到陪域的 *零元素* 的元素，记号为 $\mathrm{Ker}$。假设有某个同态 $\phi$，那么在这个同态下的核就记为 $\mathrm{Ker} \phi$。这里的零元素应该是代数结构中普遍存在的单位元，而称为零元素的主要原因是因为对我们即将研究的许多代数结构而言，它们上面的结构实际上是交换的。交换的运算我们会叫它们 *加法*。而我们熟悉的加法的单位元就是 $0$。

我们上面只说了核底下依赖的集合是怎样选取的，然而由于同态的性质，核上经常都会有额外的代数结构。这一点很容易确定：对群而言，单位元自己本身就是一个平凡群，其上的唯一运算就是单位元和单位元进行运算之后得到单位元自己。那么既然单位元是一个群，由同态的要求，我们马上就可以得知，群同态的核很自然地就拥有群结构。不但如此，我们在此不加说明地断言：群同态的核总是群的定义域的一个正规子群！而有了正规子群，我们马上就可以讨论定义域的群商去这个同态的核所得到的商群了。事实上，群同构基本定理中就和同态的核关系非常密切，且经常使用核来构造商群。

对于核而言，我们还想提到这三点：首先核一定是依赖于某个同态的，没有同态是没有办法讨论核的。从它的记号就可以看出，我们选择使用 $\mathrm{Ker}$ 记录同态的符号而非其定义域，然而也请切记核作为集合而言一定是定义域的子集。

其次想要提到的是核在 *同调代数* （也许也不是？）中的意义：核衡量了同态的性质，告诉了我们一个同态距离单态究竟有多远。这是由于这样的定理：*核中的元素只有一个（也就是单位元）当且仅当同态是单态*。那么如果核越大，同态距离单态就越远了；核越小，同态就越像单态。

最后一点也许会复杂一些，我们想提到的是：群同态的核由于一定是正规子群，而正规子群又一定能够被商掉。考虑我们上面提过的构造商结构的过程：被商的集合/结构是作为一个选择方式出现，而这个选择方式就是这个结构中的所有元素都被视为同一个元素。我们进行这样的猜测：这样用核来构造的商群中的元素，每个元素都是一个集合，而这些集合与核是相似的：它们都有同样的大小。幸运的是这样的猜测是成立的。最后也不卖关子了：商群中的元素就是正规子群的陪集，而每个陪集的大小都是相等的。所谓的陪集就是把群里面的子群用某个元素乘一下（移动一下）。这里说 “集” 有两个层面，一是我们不计划赋予它别的结构，他们就作为集合存在于商群；二是我们没法赋予群结构，除了最平凡的那个正规子群。更一般的陪集是没有办法满足单位元要求以及逆元要求的。

核真的很重要，所以我们聊了许多。不过这主要是由于核与商群之间重要的联系。有了这样的铺垫，我们理解像将会更迅速：像也是一个子群，但不是更特殊的正规子群。

---

像我们早就熟悉了，就集合层面而言，就是值域 “更代数”的一个名字。而同样由于同态的存在，像也一定是一个群。但是不同于核，像并不总是正规子群。这真是一个悲伤的故事，我们不能再愉快地构造商群了。也许你之前幻想着，既然核可以衡量同态与单态的距离，是不是像也可以衡量同态与满态的距离呢？因为很显然可以看到，像越大越可能是满态，像与陪域相同那就是满态了。然而很可惜，我们不用这种方式。

但是我们有三个好消息：第一条是，虽然像不是个正规子群，但是我们依旧可以用像构造商结构！第二条则是，虽然像不能衡量同态的信息，但是它构造的商结构可以！我们还给它一个特别的名字：余核 (Cokernel)。第三条则是，我们其实要研究的是交换群，而对交换群而言，所有的子群都是正规子群的！这样一来，前面讲的商结构也就可以是商群啦。

<details><summary>子群，商群，陪集，商结构，到底是怎么回事？</summary> 
在讲商群时，终究还是无法避免陪集的概念。陪集和商群之间到底是什么样的关系？陪集之间又有什么样的联系？陪集到底是什么样子的东西？*商* 究竟是什么？我们讲了这么久的子群，正规子群，它们到底都是啥？这里我们斗胆写一写吧。

先看看子群吧，其实子群的概念很简单：一个群的子群，实际上就是子集加上原群的运算。这样一来，子群的单位元一定就是原群的单位元，而子群的运算就是原群的运算了。这个还是相对比较简单的一个概念，麻烦的是所谓的正规子群。而为了讨论正规子群，必须要讨论所谓的陪集。我们把陪集往后放一放，先讲商群中的元素们：陪集。

我们已经提到，商群就是对群按照其正规子群的需求进行分类从而得到的一个更小的群。这个更小的群里面是一个个的陪集，我们讲陪集中的元素都是相互等价的，因此，这个更小的群里的元素虽然都是集合，但是完全可以从每个集合中取一个元素来代表这个集合（由于等价关系），这个元素就被称为代表元。所以你可能会见到商群中的元素是用一个个原群中的元素带上标记构成的。但是还请记住，商群中的元素始终都是集合，也就是陪集。

我们再谈谈陪集。陪集是这样一个集合：它必须依赖一个群里的元素，以及这个群的一个子群。我们记较大的群为 $G$，它的子群为 $H$。那么我们取 $G$ 中的一个元素 $g$ 之后，再和子群 $H$结合一下，就得到了所谓的陪集了。具体是这样的：

1.  还是先提醒：$H$ 是住在 $G$ 里面的，它们拥有一模一样的运算，所以 $G$ 中的元素是完全可以与 $H$ 中的元素运算的。
2.  

</details>


[^1]:我其实挺纠结应该说 *函数* 还是 *映射* 的。函数我认为用以指代给集合上每个点指派一个数字的东西更合适，更符合我心目中对函**数**的想象。而映射又太广泛了，因为很多地方代数结构之间不会一板一眼地讲 “同态”，而是直接就说映射了。思来想去，还是函数更合适，毕竟接触最多，接受程度也最广泛。

