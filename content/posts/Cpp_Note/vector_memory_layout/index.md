---
categories:
# - Mathematics
- Programming
# - Phase Field
# - Others
tags:
- C++
title: "C++ Vector 的内存布局"
description: "C++ Vector 容器的内存是连续的吗？"
date: 2025-03-24T09:53:29+08:00
image: 
math: true
license: 
hidden: false
comments: true
draft: true
---

*探索一下 C++ 的容器 `vector` 的内存布局，也算是解答我自己的一些疑虑咯*

## 先介绍一下 `vector` 的基本情况咯

`vector` 是由 C++ 标准库提供的一个容器模板类。这里不打算仔细介绍什么是容器，模板，什么是类，我们直接指出：`vector` 的作用就是一个更好用的数组。“类”是说明它自己带了一些好用的函数，称为“方法”，“模板”就是说它需要接受一个类型作为参数才能成为一个完整的类型，就像数组必须说明是什么东西的数组一样。最后“容器”就是说它是一类经过了特殊优化的模板类，和别的容器一起共用着一些方法与成员，且有一类公共的算法可以用在它们上面。

和传统的数组相比，`vector`有这样的几个特点：首先它符合 *RAII* (Resource Allocation Is Initialization) 的要求，即自动管理内存，离开作用域时自动销毁，而传统的数组则不是很满足 *RAII* 的条件；其次就是 `vector` 是动态大小的，在使用时不需要在编译期就了解这个东西的大小，程序会根据需求自动分配内存。虽然后者在 C 中也能实现，比如指针+ `malloc` 的组合，然而这样的组合需要直接面对自己创建的裸指针 (Raw Pointer)，一个不小心就很容易造成内存泄漏，所以使用时要特别注意。最后就是，相比起数组这样较基础的数据类型，使用 `vector` 的内建函数（方法）可以避免自己造一些轮子，会比较方便。

即便 `vector` 看起来这么好，其实还是有人会担心 `vector` 会引入额外的运行开销。特别是，有人可能会怀疑：我使用数组或者指针+`malloc` 得到的内存空间我是明确知道时连续的，那 `vector` 呢？它经过这样的包装之后，还拥有连续内存空间吗？这篇文章就是打算探讨这个问题。

## `vector` 为什么“可能”会比较低效？

我们这里不打算介绍什么复杂的内容，比如什么 allocator 或者内存调度机制。我们只对“指针+`malloc`”方法以及`vector`方法是怎么获取可用内存空间的方法进行简单说明。

不过在进入具体的内存分配过程介绍之前，我们希望能先介绍几个概念：

### 堆与栈

我们写好的程序在运行时，需要同系统进行交互，借由多种系统调用完成任务。而在程序运行的过程中需要的内存空间则也是由系统进行分配的。一般我们将系统分配的内存空间划分为两块，一块叫*堆*，而另一块儿叫*栈*。请注意这里的堆栈并不能直接对应数据结构，请仅将其看作内存空间的称呼。

程序运行时，系统会将调用的函数一个一个压入调用栈中，栈空间内实行先进后出（也是栈这一称呼的来源），连带着函数需要的变量也是一样压入栈内的。然而，栈实际上相对比较小，如果在栈内存放了过多的资源导致栈内空间不足，程序则会出现所谓的栈溢出 (Stack Overflow)。不过好消息是，系统并不会傻傻地将任何东西都放在宝贵的栈空间内，在存储大量内容时，可以把这些内容存储在堆中。

堆和栈都是由系统负责内存分配的，区别在于，栈是严格执行先进后出的，且空间有限，只负责函数调用等，资源会被自动回收；而堆则不同，堆相比栈而言会比较大，里面的资源不需要什么先进后出，然而在程序不再用到里面存储的资源时，系统也不会自动回收它们，取用这些内存资源的方式也是需要通过指针进行读取或写入的。所以相比栈空间，堆空间的运用更需要一些技巧，如果使用比较传统的方式的话。有句话很好地形容了堆：垃圾堆。如果能很好地管理这里的内容，那样就会很好用，否则就会让系统东留一块儿垃圾西留一块儿垃圾，最后变成垃圾堆。所以C/C++编程的一大技巧就是使用好堆上的空间。

那么，我们应该如何，按照上面所述的方法，进行堆上的内存管理呢？

### `malloc` 的内存分配方法

传统的指针+`malloc`方法（后面就直接叫指针方法好了）大概是这样工作的：首先声明一个指针，它不指向什么具体的内存地址（空指针），然后再通过 `malloc` 中传入的参数来决定从这个指针开始要给它多大的连续空间（一个内存段），最后让这个指针指向这个内存段的头部，从而完成内存分配。这样的方法最大的特点是它不需要编译时就确定好需要多大的内存，而是通过 `malloc` “动态地” 分配一段内存，然后交给这个指针进行管理。在 C 语言写的程序中，基本都是这么进行运行期间的内存分配的。

这样的内存分配方法，在 C 语言兴起的时候，是非常伟大的。然而这个方法存在着很多的问题：首先就是指针操作的复杂性。很多程序运行崩溃，都是由指针造成的，或者是忘记删除已经不需要的资源，或者是引用了空指针或者悬垂指针。另外就是使用 `malloc` 分配的内存实际上也没有那么动态：如果你声明了 100 字节的内存，那就一定而且只有 100 字节的连续内存可以用：如果你实际上用不到 100 字节，那多余的空间会被浪费，不过这样还好；而当你用了超过 100 个字节的数据，却尝试将它们放在 100 个字节的内存段中时，多出来的部分会直接被截断，也就是说多出来的部分就消失了。这实在是一个坏消息。而即便你注意了资源的声明与使用，使用裸指针管理资源的过程也比较繁琐：你需要使用一些诸如 `memcpy` 这样的函数来管理内存，这些函数操作非常精细，它会要求操作的字节数量，这很好但也许会显得有点太麻烦了。

所以，我更愿意称使用 `malloc` 进行内存管理更适合 “高级用户”，对于比较一般的操作，`malloc` 显得有点杀鸡用牛刀了。那么，`vector` 是“杀鸡刀”吗？

### `vector` 的内存分配方法

我们首先给出肯定的回复：Yes, `vector` 是一把刚刚好的杀鸡刀。实际上也许 `vector` 会比想象中的更好用。`vector` 首先是符合 *RAII* 的，这使得我们不需要特别关注声明的资源：这些资源在离开其作用域时就自动被销毁了。不用再担心内存泄漏，也不用担心空指针之类。另外 `vector` 虽然实际上是将资源放在堆上的，对 `vector` 的操作实际上就像是在栈上操作它一样，对它的操作要比指针操作之类要直观的多。最后，使用 `vector` 不用担心空间不足：当 `vector` 内的空间不足以容纳新的东西时，`vector` 会自动增加其容量，来容纳这些新的东西。这个操作在编程侧是近乎无感的：你可以直接把 `vector` 当做一个无限容量的容器，你要做的事情就是往里装就 OK 了。

也许有人会担心：`vector` 就一点问题都没有？很可惜， `vector` 也是需要正确使用的，否则就是会很低效。这一点主要体现在 `vector` 的自动扩容上。`vector` 的扩容机制是这样的：如果容量不够，就在当前容量上乘2（或1.5，取决于具体实现）来容纳新东西。乍一听没什么问题，而实际上扩容是一个很复杂也很慢的过程。我们下面会更深入地聊聊这个问题。另外，`vector` 的内存真的是连续的吗？可以通过什么方法来看到其内存布局吗？我们后面也会尝试使用程序来把内存地址打印到屏幕上，看看是个什么样子。

最后，`vector` 实际上也提供了和 C 的裸指针相容的对象，通过调用 `vector::data()` 方法即可获得 `vector` 内存段对应的裸指针。这样一来，需要精细操作或者与老 API 做兼容时也很方便。




```cpp
#include <iostream>
#include <vector>

int main() {
    // Declare two vector, one for element push_back,
    // and another one for recording the elements address
    std::vector<int> array;
    std::vector<int *> array_element_address;

    //? Reserve the space or not ?//
    // array.reserve(100);

    // Start the element push back
    for (int i = 0; i < 10000; i++) {
        array.push_back(i);
        array_element_address.push_back(&array.back());
    }

    // Output the length between address of the first and last element ?
    std::cout << array.end() - array.begin() << std::endl;
    // Output the length between the "ACTUAL" address the first and last element in array
    std::cout << *(array_element_address.end() - 1) - *array_element_address.begin() << std::endl;
}
```
